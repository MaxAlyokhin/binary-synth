# Binary Synth

_Синтез аудио из двоичного кода любого файла_

[![Uptime Robot status](https://img.shields.io/uptimerobot/status/m795264551-bb4c959b31b6ff94b02f9545)](https://bs.stranno.su) [![Uptime Robot status](https://img.shields.io/uptimerobot/ratio/m795264551-bb4c959b31b6ff94b02f9545)](https://bs.stranno.su)

**Демо**: https://bs.stranno.su

**Видео**: https://youtu.be/5LMYiLwfvRg

![](https://store.stranno.su/bs/fuji.png)

Веб-синтезатор, генерирующий звук из двоичного кода любых файлов. Может синтезировать звук прямо в браузере, либо быть генератором MIDI-сообщений во внешние устройства или DAW, превращая любой файл в партитуру. Весь код приложения написан на Javascript и вместе со всем необходимым упаковывается в один .html файл размером около 750kb. Синтезатору не нужен интернет, его можно скачать и запускать локально на любом устройстве где есть браузер.

Приложение последовательно читает файл и за счёт высокой скорости чтения и случайной величины отклонения длительности чтения, мы можем получить достаточно непредсказуемую генерацию нюансов тембра, а при определённых настройках перейти в гранулярный синтез.

## Принцип работы

Все данные на любом компьютере или смартфоне представлены в виде файлов (являющихся, по своей сути, текстами). Содержанием этих файлов в конечном итоге являются просто нули и единицы. И эти нули и единицы, в общем-то, все одинаковые, поэтому нам нужен интерпретатор, для того чтобы извлечь смысл из этих текстов. Можно сказать, что формат файла (.mp3, .docx и т.д.) это просто указатель, какому интерпретатору надо передать текст, чтобы из него извлечь смысл.

Но что, если формат файла и интерпретатор не совпадают?

Что касается музыкальных экспериментов, то ранее были, например, попытки "воспроизвести" текстовый или иной файл через аудио-редактор.

Мы могли бы пойти дальше и написать собственный интерпретатор, который смотрел бы на файлы безотносительно формата, использовал собственную "манеру чтения" исходных нулей и единиц и на этой основе предоставлял полноценную систему управляемого синтеза звуков.

1. Мы можем интерпретировать файлы как массив чисел. То есть, мы разбиваем непрерывный машинный код на _слова_ некоторой информационной ёмкости (разрядности):

-   8 бит (числа от 0 до 255)
-   16 бит (числа от 0 до 65 535)

2. Тогда, каждое слово есть команда, определяющая частоту звука

3. На уровне всей системы мы задаём глобальные параметры:

-   скорость интерпретации
-   наличие случайной величины разброса скорости интерпретации
-   музыкальный строй (или его отсутствие), диапазон нот/частот; по этому диапазону равномерно сопоставляются частоты по 256 или 65 536 возможным комбинациям нулей и единиц
-   зацикленность воспроизведения
-   режим MIDI
-   плавный или резкий переход между командами
-   настройки виртуальных устройств, необходимых для синтеза (осциллятор, фильтр, LFO), либо настройки MIDI

4. Чтобы снизить нагрузку на устройство, делим файл на куски по 500 команд

5. Рекурсивно планируем управление синтезом, читая по 500 команд в итерации и используя глобальные параметры

6. Если дошли до конца файла, прекращаем исполнение, либо начинаем заново

## Переход в гранулярный режим

> **Note**: Здесь и далее используются термины интерфейса инструмента. Их описание смотрите ниже в разделе Особенности интерфейса

Гранулярный синтез оперирует мелкими кусочками звуков — акустическими пикселями. Принято считать, что гранулярный синтез "начинается" при оперировании звуками <50мс. При значениях `commands range` * `reading speed` = <50 мы начинаем оперировать уже акустическими пикселями.

При этом каждую команду из `commands range` можно считать "субпикселем" (вейвлетом), который, при включённом `random time gap`, каждый раз уникален, а пиксель, соответственно, уникален кратно количеству субпикселей. В итоге мы получаем мутирующий тембр.

В классическом гранулярном синтезе пиксели играют одновременно и параллельно и их количество может меняться со временем. В BS же пиксели образуют нить, по которой мы движемся.

То есть, в обычном гранулярном синтезе на слушателя опрокидывают грузовик с песком, где каждая песчинка это акустический пиксель, то здесь этот песок высыпается через воронку диаметром с одну песчинку и вот эту тонкую струю мы и наблюдаем.

## MIDI

При включении MIDI-режима автоматически выбирается первый попавшийся порт из доступных и его первый канал. Далее последовательно при чтении посылается сигнал `noteOn`, через время `reading speed` посылается сигнал `noteOff`. В `continuous` режиме после каждого `noteOn` посылается `Pitch` сигнал, чтобы попасть в нужную частоту.

MIDI-сообщения могут посылаться:

-   в соседние вкладки и окна браузеров, если они слушают MIDI (например, в веб-аналог [DX7](http://mmontag.github.io/dx7-synth-js))
-   в DAW и прочие приложения, где есть виртуальные синтезаторы (то есть BS может управлять, например, синтезатором в Ableton)
-   во внешние устройства, поддерживающие MIDI и подключённые к компьютеру

Для передачи MIDI-сообщений в DAW на устройствах Windows можно воспользоваться [loopMIDI](https://www.tobias-erichsen.de/software/loopmidi.html).

> **Note**: После любых манипуляций с MIDI-портами (подключение/отключение/переподключение) необходимо полностью перезапустить браузер, закрыв все окна браузера если их несколько

> **Note**: MIDI-сообщения генерируются только на десктопе

## Особенности интерфейса

-   `Reading speed` — скорость интерпретации; на высоких скоростях более 0.001 приложение может работать нестабильно

-   `Bitness` — мы можем разделить двоичный код на слова по 8 или 16 бит, что меняет количество доступных частот (256 или 65536)

-   `Frequency generation mode`

    -   `continuous` — непрерывное распределение частот
    -   `tempered` — распределение по 12-ступенному равномерно-темперированному строю. Доступны ноты от C-2 до B8

-   `Transition type` — переход между частотами

    -   `immediately` — моментально, грубый переход
    -   `linear` — линейно до следующей частоты
    -   `exponential` — экспоненциально до следующей частоты

-   `Random time gap` — добавление случайной величины времени до следующего звука в пределах параметра `reading speed`. Делает звук менее "роботизированным", так как расстояние до каждого звука немного отличается и это добавляет больше "живости" игре

-   `Commands range` — позволяет играть не весь файл, а его определённую часть

-   `Solid Mode` — режим "сплошного нажатия", не посылает команды `noteOff`; если подряд идут одинаковые команды (и как следствие ноты), то даже noteOn не посылается. В конце посылается `allSoundOff`. На некоторых синтезаторах позволять осуществить плавные переходы между нотами

- У некоторых полей ввода есть клавиатурное сокращение: при нажатии соответствующей клавиши автоматически наводится фокус на элемент. При зажатии клавиши и одновременном движении мышью можно плавно менять значения. По оси Y при движении мыши располагается "мощность" изменения значения

## Запуск локально и сборка проекта

### Просто скопировать приложение

Всё необходимое для работы системы заложено в единственный `.html` файл, который можно скачать в папке `dist`, либо просто перейти на https://bs.strannо.su и, нажав правую кнопку мыши, в меню выбрать Сохранить как.

### Собрать билд локально для доработки кода

Tech stack: Vue3 + Pinia + Vite.

1. Скачать и установить LTS версию Node.js
2. Скачать код напрямую с Github, либо через `git clone`
3. В папке с проектом в терминале выполнить:

```bash
npm i
npm run dev # development-сборка
npm run build # production-сборка, генерирует index.html со всем необходимым
```

Для тестов MIDI можно пользоваться этим ресурсом https://studiocode.dev/midi-monitor/